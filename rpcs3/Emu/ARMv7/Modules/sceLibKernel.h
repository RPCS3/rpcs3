#pragma once

#include "Utilities/SleepQueue.h"
#include "Emu/ARMv7/ErrorCodes.h"

// Error Codes

enum SceLibKernelError : s32
{
	SCE_KERNEL_ERROR_ERROR                                        = ERROR_CODE(0x80020001),
	SCE_KERNEL_ERROR_NOT_IMPLEMENTED                              = ERROR_CODE(0x80020002),
	SCE_KERNEL_ERROR_INVALID_ARGUMENT                             = ERROR_CODE(0x80020003),
	SCE_KERNEL_ERROR_INVALID_ARGUMENT_SIZE                        = ERROR_CODE(0x80020004),
	SCE_KERNEL_ERROR_INVALID_FLAGS                                = ERROR_CODE(0x80020005),
	SCE_KERNEL_ERROR_ILLEGAL_SIZE                                 = ERROR_CODE(0x80020006),
	SCE_KERNEL_ERROR_ILLEGAL_ADDR                                 = ERROR_CODE(0x80020007),
	SCE_KERNEL_ERROR_UNSUP                                        = ERROR_CODE(0x80020008),
	SCE_KERNEL_ERROR_ILLEGAL_MODE                                 = ERROR_CODE(0x80020009),
	SCE_KERNEL_ERROR_ILLEGAL_ALIGNMENT                            = ERROR_CODE(0x8002000A),
	SCE_KERNEL_ERROR_NOSYS                                        = ERROR_CODE(0x8002000B),
	SCE_KERNEL_ERROR_DEBUG_ERROR                                  = ERROR_CODE(0x80021000),
	SCE_KERNEL_ERROR_ILLEGAL_DIPSW_NUMBER                         = ERROR_CODE(0x80021001),
	SCE_KERNEL_ERROR_CPU_ERROR                                    = ERROR_CODE(0x80022000),
	SCE_KERNEL_ERROR_MMU_ILLEGAL_L1_TYPE                          = ERROR_CODE(0x80022001),
	SCE_KERNEL_ERROR_MMU_L2_INDEX_OVERFLOW                        = ERROR_CODE(0x80022002),
	SCE_KERNEL_ERROR_MMU_L2_SIZE_OVERFLOW                         = ERROR_CODE(0x80022003),
	SCE_KERNEL_ERROR_INVALID_CPU_AFFINITY                         = ERROR_CODE(0x80022004),
	SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS                        = ERROR_CODE(0x80022005),
	SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS_PERMISSION             = ERROR_CODE(0x80022006),
	SCE_KERNEL_ERROR_VA2PA_FAULT                                  = ERROR_CODE(0x80022007),
	SCE_KERNEL_ERROR_VA2PA_MAPPED                                 = ERROR_CODE(0x80022008),
	SCE_KERNEL_ERROR_VALIDATION_CHECK_FAILED                      = ERROR_CODE(0x80022009),
	SCE_KERNEL_ERROR_SYSMEM_ERROR                                 = ERROR_CODE(0x80024000),
	SCE_KERNEL_ERROR_INVALID_PROCESS_CONTEXT                      = ERROR_CODE(0x80024001),
	SCE_KERNEL_ERROR_UID_NAME_TOO_LONG                            = ERROR_CODE(0x80024002),
	SCE_KERNEL_ERROR_VARANGE_IS_NOT_PHYSICAL_CONTINUOUS           = ERROR_CODE(0x80024003),
	SCE_KERNEL_ERROR_PHYADDR_ERROR                                = ERROR_CODE(0x80024100),
	SCE_KERNEL_ERROR_NO_PHYADDR                                   = ERROR_CODE(0x80024101),
	SCE_KERNEL_ERROR_PHYADDR_USED                                 = ERROR_CODE(0x80024102),
	SCE_KERNEL_ERROR_PHYADDR_NOT_USED                             = ERROR_CODE(0x80024103),
	SCE_KERNEL_ERROR_NO_IOADDR                                    = ERROR_CODE(0x80024104),
	SCE_KERNEL_ERROR_PHYMEM_ERROR                                 = ERROR_CODE(0x80024300),
	SCE_KERNEL_ERROR_ILLEGAL_PHYPAGE_STATUS                       = ERROR_CODE(0x80024301),
	SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE                        = ERROR_CODE(0x80024302),
	SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE_UNIT                   = ERROR_CODE(0x80024303),
	SCE_KERNEL_ERROR_PHYMEMPART_NOT_EMPTY                         = ERROR_CODE(0x80024304),
	SCE_KERNEL_ERROR_NO_PHYMEMPART_LPDDR2                         = ERROR_CODE(0x80024305),
	SCE_KERNEL_ERROR_NO_PHYMEMPART_CDRAM                          = ERROR_CODE(0x80024306),
	SCE_KERNEL_ERROR_FIXEDHEAP_ERROR                              = ERROR_CODE(0x80024400),
	SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_SIZE                       = ERROR_CODE(0x80024401),
	SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_INDEX                      = ERROR_CODE(0x80024402),
	SCE_KERNEL_ERROR_FIXEDHEAP_INDEX_OVERFLOW                     = ERROR_CODE(0x80024403),
	SCE_KERNEL_ERROR_FIXEDHEAP_NO_CHUNK                           = ERROR_CODE(0x80024404),
	SCE_KERNEL_ERROR_UID_ERROR                                    = ERROR_CODE(0x80024500),
	SCE_KERNEL_ERROR_INVALID_UID                                  = ERROR_CODE(0x80024501),
	SCE_KERNEL_ERROR_SYSMEM_UID_INVALID_ARGUMENT                  = ERROR_CODE(0x80024502),
	SCE_KERNEL_ERROR_SYSMEM_INVALID_UID_RANGE                     = ERROR_CODE(0x80024503),
	SCE_KERNEL_ERROR_SYSMEM_NO_VALID_UID                          = ERROR_CODE(0x80024504),
	SCE_KERNEL_ERROR_SYSMEM_CANNOT_ALLOCATE_UIDENTRY              = ERROR_CODE(0x80024505),
	SCE_KERNEL_ERROR_NOT_PROCESS_UID                              = ERROR_CODE(0x80024506),
	SCE_KERNEL_ERROR_NOT_KERNEL_UID                               = ERROR_CODE(0x80024507),
	SCE_KERNEL_ERROR_INVALID_UID_CLASS                            = ERROR_CODE(0x80024508),
	SCE_KERNEL_ERROR_INVALID_UID_SUBCLASS                         = ERROR_CODE(0x80024509),
	SCE_KERNEL_ERROR_UID_CANNOT_FIND_BY_NAME                      = ERROR_CODE(0x8002450A),
	SCE_KERNEL_ERROR_VIRPAGE_ERROR                                = ERROR_CODE(0x80024600),
	SCE_KERNEL_ERROR_ILLEGAL_VIRPAGE_TYPE                         = ERROR_CODE(0x80024601),
	SCE_KERNEL_ERROR_BLOCK_ERROR                                  = ERROR_CODE(0x80024700),
	SCE_KERNEL_ERROR_ILLEGAL_BLOCK_ID                             = ERROR_CODE(0x80024701),
	SCE_KERNEL_ERROR_ILLEGAL_BLOCK_TYPE                           = ERROR_CODE(0x80024702),
	SCE_KERNEL_ERROR_BLOCK_IN_USE                                 = ERROR_CODE(0x80024703),
	SCE_KERNEL_ERROR_PARTITION_ERROR                              = ERROR_CODE(0x80024800),
	SCE_KERNEL_ERROR_ILLEGAL_PARTITION_ID                         = ERROR_CODE(0x80024801),
	SCE_KERNEL_ERROR_ILLEGAL_PARTITION_INDEX                      = ERROR_CODE(0x80024802),
	SCE_KERNEL_ERROR_NO_L2PAGETABLE                               = ERROR_CODE(0x80024803),
	SCE_KERNEL_ERROR_HEAPLIB_ERROR                                = ERROR_CODE(0x80024900),
	SCE_KERNEL_ERROR_ILLEGAL_HEAP_ID                              = ERROR_CODE(0x80024901),
	SCE_KERNEL_ERROR_OUT_OF_RANG                                  = ERROR_CODE(0x80024902),
	SCE_KERNEL_ERROR_HEAPLIB_NOMEM                                = ERROR_CODE(0x80024903),
	SCE_KERNEL_ERROR_SYSMEM_ADDRESS_SPACE_ERROR                   = ERROR_CODE(0x80024A00),
	SCE_KERNEL_ERROR_INVALID_ADDRESS_SPACE_ID                     = ERROR_CODE(0x80024A01),
	SCE_KERNEL_ERROR_INVALID_PARTITION_INDEX                      = ERROR_CODE(0x80024A02),
	SCE_KERNEL_ERROR_ADDRESS_SPACE_CANNOT_FIND_PARTITION_BY_ADDR  = ERROR_CODE(0x80024A03),
	SCE_KERNEL_ERROR_SYSMEM_MEMBLOCK_ERROR                        = ERROR_CODE(0x80024B00),
	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_TYPE                        = ERROR_CODE(0x80024B01),
	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_REMAP_TYPE                  = ERROR_CODE(0x80024B02),
	SCE_KERNEL_ERROR_NOT_PHY_CONT_MEMBLOCK                        = ERROR_CODE(0x80024B03),
	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_CODE                        = ERROR_CODE(0x80024B04),
	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_SIZE                        = ERROR_CODE(0x80024B05),
	SCE_KERNEL_ERROR_ILLEGAL_USERMAP_SIZE                         = ERROR_CODE(0x80024B06),
	SCE_KERNEL_ERROR_MEMBLOCK_TYPE_FOR_KERNEL_PROCESS             = ERROR_CODE(0x80024B07),
	SCE_KERNEL_ERROR_PROCESS_CANNOT_REMAP_MEMBLOCK                = ERROR_CODE(0x80024B08),
	SCE_KERNEL_ERROR_SYSMEM_PHYMEMLOW_ERROR                       = ERROR_CODE(0x80024C00),
	SCE_KERNEL_ERROR_CANNOT_ALLOC_PHYMEMLOW                       = ERROR_CODE(0x80024C01),
	SCE_KERNEL_ERROR_UNKNOWN_PHYMEMLOW_TYPE                       = ERROR_CODE(0x80024C02),
	SCE_KERNEL_ERROR_SYSMEM_BITHEAP_ERROR                         = ERROR_CODE(0x80024D00),
	SCE_KERNEL_ERROR_CANNOT_ALLOC_BITHEAP                         = ERROR_CODE(0x80024D01),
	SCE_KERNEL_ERROR_LOADCORE_ERROR                               = ERROR_CODE(0x80025000),
	SCE_KERNEL_ERROR_ILLEGAL_ELF_HEADER                           = ERROR_CODE(0x80025001),
	SCE_KERNEL_ERROR_ILLEGAL_SELF_HEADER                          = ERROR_CODE(0x80025002),
};

enum SceLibKernelError0 : s32
{
	SCE_KERNEL_ERROR_EXCPMGR_ERROR                                = ERROR_CODE(0x80027000),
	SCE_KERNEL_ERROR_ILLEGAL_EXCPCODE                             = ERROR_CODE(0x80027001),
	SCE_KERNEL_ERROR_ILLEGAL_EXCPHANDLER                          = ERROR_CODE(0x80027002),
	SCE_KERNEL_ERROR_NOTFOUND_EXCPHANDLER                         = ERROR_CODE(0x80027003),
	SCE_KERNEL_ERROR_CANNOT_RELEASE_EXCPHANDLER                   = ERROR_CODE(0x80027004),
	SCE_KERNEL_ERROR_INTRMGR_ERROR                                = ERROR_CODE(0x80027100),
	SCE_KERNEL_ERROR_ILLEGAL_CONTEXT                              = ERROR_CODE(0x80027101),
	SCE_KERNEL_ERROR_ILLEGAL_INTRCODE                             = ERROR_CODE(0x80027102),
	SCE_KERNEL_ERROR_ILLEGAL_INTRPARAM                            = ERROR_CODE(0x80027103),
	SCE_KERNEL_ERROR_ILLEGAL_INTRPRIORITY                         = ERROR_CODE(0x80027104),
	SCE_KERNEL_ERROR_ILLEGAL_TARGET_CPU                           = ERROR_CODE(0x80027105),
	SCE_KERNEL_ERROR_ILLEGAL_INTRFILTER                           = ERROR_CODE(0x80027106),
	SCE_KERNEL_ERROR_ILLEGAL_INTRTYPE                             = ERROR_CODE(0x80027107),
	SCE_KERNEL_ERROR_ILLEGAL_HANDLER                              = ERROR_CODE(0x80027108),
	SCE_KERNEL_ERROR_FOUND_HANDLER                                = ERROR_CODE(0x80027109),
	SCE_KERNEL_ERROR_NOTFOUND_HANDLER                             = ERROR_CODE(0x8002710A),
	SCE_KERNEL_ERROR_NO_MEMORY                                    = ERROR_CODE(0x8002710B),
	SCE_KERNEL_ERROR_DMACMGR_ERROR                                = ERROR_CODE(0x80027200),
	SCE_KERNEL_ERROR_ALREADY_QUEUED                               = ERROR_CODE(0x80027201),
	SCE_KERNEL_ERROR_NOT_QUEUED                                   = ERROR_CODE(0x80027202),
	SCE_KERNEL_ERROR_NOT_SETUP                                    = ERROR_CODE(0x80027203),
	SCE_KERNEL_ERROR_ON_TRANSFERRING                              = ERROR_CODE(0x80027204),
	SCE_KERNEL_ERROR_NOT_INITIALIZED                              = ERROR_CODE(0x80027205),
	SCE_KERNEL_ERROR_TRANSFERRED                                  = ERROR_CODE(0x80027206),
	SCE_KERNEL_ERROR_NOT_UNDER_CONTROL                            = ERROR_CODE(0x80027207),
	SCE_KERNEL_ERROR_SYSTIMER_ERROR                               = ERROR_CODE(0x80027300),
	SCE_KERNEL_ERROR_NO_FREE_TIMER                                = ERROR_CODE(0x80027301),
	SCE_KERNEL_ERROR_TIMER_NOT_ALLOCATED                          = ERROR_CODE(0x80027302),
	SCE_KERNEL_ERROR_TIMER_COUNTING                               = ERROR_CODE(0x80027303),
	SCE_KERNEL_ERROR_TIMER_STOPPED                                = ERROR_CODE(0x80027304),
	SCE_KERNEL_ERROR_THREADMGR_ERROR                              = ERROR_CODE(0x80028000),
	SCE_KERNEL_ERROR_DORMANT                                      = ERROR_CODE(0x80028001),
	SCE_KERNEL_ERROR_NOT_DORMANT                                  = ERROR_CODE(0x80028002),
	SCE_KERNEL_ERROR_UNKNOWN_THID                                 = ERROR_CODE(0x80028003),
	SCE_KERNEL_ERROR_CAN_NOT_WAIT                                 = ERROR_CODE(0x80028004),
	SCE_KERNEL_ERROR_ILLEGAL_THID                                 = ERROR_CODE(0x80028005),
	SCE_KERNEL_ERROR_THREAD_TERMINATED                            = ERROR_CODE(0x80028006),
	SCE_KERNEL_ERROR_DELETED                                      = ERROR_CODE(0x80028007),
	SCE_KERNEL_ERROR_WAIT_TIMEOUT                                 = ERROR_CODE(0x80028008),
	SCE_KERNEL_ERROR_NOTIFY_CALLBACK                              = ERROR_CODE(0x80028009),
	SCE_KERNEL_ERROR_WAIT_DELETE                                  = ERROR_CODE(0x8002800A),
	SCE_KERNEL_ERROR_ILLEGAL_ATTR                                 = ERROR_CODE(0x8002800B),
	SCE_KERNEL_ERROR_EVF_MULTI                                    = ERROR_CODE(0x8002800C),
	SCE_KERNEL_ERROR_WAIT_CANCEL                                  = ERROR_CODE(0x8002800D),
	SCE_KERNEL_ERROR_EVF_COND                                     = ERROR_CODE(0x8002800E),
	SCE_KERNEL_ERROR_ILLEGAL_COUNT                                = ERROR_CODE(0x8002800F),
	SCE_KERNEL_ERROR_ILLEGAL_PRIORITY                             = ERROR_CODE(0x80028010),
	SCE_KERNEL_ERROR_MUTEX_RECURSIVE                              = ERROR_CODE(0x80028011),
	SCE_KERNEL_ERROR_MUTEX_LOCK_OVF                               = ERROR_CODE(0x80028012),
	SCE_KERNEL_ERROR_MUTEX_NOT_OWNED                              = ERROR_CODE(0x80028013),
	SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF                             = ERROR_CODE(0x80028014),
	SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN                          = ERROR_CODE(0x80028015),
	SCE_KERNEL_ERROR_FAST_MUTEX_RECURSIVE                         = ERROR_CODE(0x80028016),
	SCE_KERNEL_ERROR_FAST_MUTEX_LOCK_OVF                          = ERROR_CODE(0x80028017),
	SCE_KERNEL_ERROR_FAST_MUTEX_FAILED_TO_OWN                     = ERROR_CODE(0x80028018),
	SCE_KERNEL_ERROR_FAST_MUTEX_NOT_OWNED                         = ERROR_CODE(0x80028019),
	SCE_KERNEL_ERROR_FAST_MUTEX_OWNED                             = ERROR_CODE(0x8002801A),
	SCE_KERNEL_ERROR_ALARM_CAN_NOT_CANCEL                         = ERROR_CODE(0x8002801B),
	SCE_KERNEL_ERROR_INVALID_OBJECT_TYPE                          = ERROR_CODE(0x8002801C),
	SCE_KERNEL_ERROR_KERNEL_TLS_FULL                              = ERROR_CODE(0x8002801D),
	SCE_KERNEL_ERROR_ILLEGAL_KERNEL_TLS_INDEX                     = ERROR_CODE(0x8002801E),
	SCE_KERNEL_ERROR_KERNEL_TLS_BUSY                              = ERROR_CODE(0x8002801F),
	SCE_KERNEL_ERROR_DIFFERENT_UID_CLASS                          = ERROR_CODE(0x80028020),
	SCE_KERNEL_ERROR_UNKNOWN_UID                                  = ERROR_CODE(0x80028021),
	SCE_KERNEL_ERROR_SEMA_ZERO                                    = ERROR_CODE(0x80028022),
	SCE_KERNEL_ERROR_SEMA_OVF                                     = ERROR_CODE(0x80028023),
	SCE_KERNEL_ERROR_PMON_NOT_THREAD_MODE                         = ERROR_CODE(0x80028024),
	SCE_KERNEL_ERROR_PMON_NOT_CPU_MODE                            = ERROR_CODE(0x80028025),
	SCE_KERNEL_ERROR_ALREADY_REGISTERED                           = ERROR_CODE(0x80028026),
	SCE_KERNEL_ERROR_INVALID_THREAD_ID                            = ERROR_CODE(0x80028027),
	SCE_KERNEL_ERROR_ALREADY_DEBUG_SUSPENDED                      = ERROR_CODE(0x80028028),
	SCE_KERNEL_ERROR_NOT_DEBUG_SUSPENDED                          = ERROR_CODE(0x80028029),
	SCE_KERNEL_ERROR_CAN_NOT_USE_VFP                              = ERROR_CODE(0x8002802A),
	SCE_KERNEL_ERROR_RUNNING                                      = ERROR_CODE(0x8002802B),
	SCE_KERNEL_ERROR_EVENT_COND                                   = ERROR_CODE(0x8002802C),
	SCE_KERNEL_ERROR_MSG_PIPE_FULL                                = ERROR_CODE(0x8002802D),
	SCE_KERNEL_ERROR_MSG_PIPE_EMPTY                               = ERROR_CODE(0x8002802E),
	SCE_KERNEL_ERROR_ALREADY_SENT                                 = ERROR_CODE(0x8002802F),
	SCE_KERNEL_ERROR_CAN_NOT_SUSPEND                              = ERROR_CODE(0x80028030),
	SCE_KERNEL_ERROR_FAST_MUTEX_ALREADY_INITIALIZED               = ERROR_CODE(0x80028031),
	SCE_KERNEL_ERROR_FAST_MUTEX_NOT_INITIALIZED                   = ERROR_CODE(0x80028032),
	SCE_KERNEL_ERROR_THREAD_STOPPED                               = ERROR_CODE(0x80028033),
	SCE_KERNEL_ERROR_THREAD_SUSPENDED                             = ERROR_CODE(0x80028034),
	SCE_KERNEL_ERROR_NOT_SUSPENDED                                = ERROR_CODE(0x80028035),
	SCE_KERNEL_ERROR_WAIT_DELETE_MUTEX                            = ERROR_CODE(0x80028036),
	SCE_KERNEL_ERROR_WAIT_CANCEL_MUTEX                            = ERROR_CODE(0x80028037),
	SCE_KERNEL_ERROR_WAIT_DELETE_COND                             = ERROR_CODE(0x80028038),
	SCE_KERNEL_ERROR_WAIT_CANCEL_COND                             = ERROR_CODE(0x80028039),
	SCE_KERNEL_ERROR_LW_MUTEX_NOT_OWNED                           = ERROR_CODE(0x8002803A),
	SCE_KERNEL_ERROR_LW_MUTEX_LOCK_OVF                            = ERROR_CODE(0x8002803B),
	SCE_KERNEL_ERROR_LW_MUTEX_UNLOCK_UDF                          = ERROR_CODE(0x8002803C),
	SCE_KERNEL_ERROR_LW_MUTEX_RECURSIVE                           = ERROR_CODE(0x8002803D),
	SCE_KERNEL_ERROR_LW_MUTEX_FAILED_TO_OWN                       = ERROR_CODE(0x8002803E),
	SCE_KERNEL_ERROR_WAIT_DELETE_LW_MUTEX                         = ERROR_CODE(0x8002803F),
	SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE                           = ERROR_CODE(0x80028040),
	SCE_KERNEL_ERROR_RW_LOCK_RECURSIVE                            = ERROR_CODE(0x80028041),
	SCE_KERNEL_ERROR_RW_LOCK_LOCK_OVF                             = ERROR_CODE(0x80028042),
	SCE_KERNEL_ERROR_RW_LOCK_NOT_OWNED                            = ERROR_CODE(0x80028043),
	SCE_KERNEL_ERROR_RW_LOCK_UNLOCK_UDF                           = ERROR_CODE(0x80028044),
	SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_LOCK                       = ERROR_CODE(0x80028045),
	SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_UNLOCK                     = ERROR_CODE(0x80028046),
};

enum SceLibKernelError1 : s32
{
	SCE_KERNEL_ERROR_PROCESSMGR_ERROR                             = ERROR_CODE(0x80029000),
	SCE_KERNEL_ERROR_INVALID_PID                                  = ERROR_CODE(0x80029001),
	SCE_KERNEL_ERROR_INVALID_PROCESS_TYPE                         = ERROR_CODE(0x80029002),
	SCE_KERNEL_ERROR_PLS_FULL                                     = ERROR_CODE(0x80029003),
	SCE_KERNEL_ERROR_INVALID_PROCESS_STATUS                       = ERROR_CODE(0x80029004),
	SCE_KERNEL_ERROR_INVALID_BUDGET_ID                            = ERROR_CODE(0x80029005),
	SCE_KERNEL_ERROR_INVALID_BUDGET_SIZE                          = ERROR_CODE(0x80029006),
	SCE_KERNEL_ERROR_CP14_DISABLED                                = ERROR_CODE(0x80029007),
	SCE_KERNEL_ERROR_EXCEEDED_MAX_PROCESSES                       = ERROR_CODE(0x80029008),
	SCE_KERNEL_ERROR_PROCESS_REMAINING                            = ERROR_CODE(0x80029009),
	SCE_KERNEL_ERROR_IOFILEMGR_ERROR                              = ERROR_CODE(0x8002A000),
	SCE_KERNEL_ERROR_IO_NAME_TOO_LONG                             = ERROR_CODE(0x8002A001),
	SCE_KERNEL_ERROR_IO_REG_DEV                                   = ERROR_CODE(0x8002A002),
	SCE_KERNEL_ERROR_IO_ALIAS_USED                                = ERROR_CODE(0x8002A003),
	SCE_KERNEL_ERROR_IO_DEL_DEV                                   = ERROR_CODE(0x8002A004),
	SCE_KERNEL_ERROR_IO_WOULD_BLOCK                               = ERROR_CODE(0x8002A005),
	SCE_KERNEL_ERROR_MODULEMGR_START_FAILED                       = ERROR_CODE(0x8002D000),
	SCE_KERNEL_ERROR_MODULEMGR_STOP_FAIL                          = ERROR_CODE(0x8002D001),
	SCE_KERNEL_ERROR_MODULEMGR_IN_USE                             = ERROR_CODE(0x8002D002),
	SCE_KERNEL_ERROR_MODULEMGR_NO_LIB                             = ERROR_CODE(0x8002D003),
	SCE_KERNEL_ERROR_MODULEMGR_SYSCALL_REG                        = ERROR_CODE(0x8002D004),
	SCE_KERNEL_ERROR_MODULEMGR_NOMEM_LIB                          = ERROR_CODE(0x8002D005),
	SCE_KERNEL_ERROR_MODULEMGR_NOMEM_STUB                         = ERROR_CODE(0x8002D006),
	SCE_KERNEL_ERROR_MODULEMGR_NOMEM_SELF                         = ERROR_CODE(0x8002D007),
	SCE_KERNEL_ERROR_MODULEMGR_NOMEM                              = ERROR_CODE(0x8002D008),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_LIB                        = ERROR_CODE(0x8002D009),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_STUB                       = ERROR_CODE(0x8002D00A),
	SCE_KERNEL_ERROR_MODULEMGR_NO_FUNC_NID                        = ERROR_CODE(0x8002D00B),
	SCE_KERNEL_ERROR_MODULEMGR_NO_VAR_NID                         = ERROR_CODE(0x8002D00C),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_TYPE                       = ERROR_CODE(0x8002D00D),
	SCE_KERNEL_ERROR_MODULEMGR_NO_MOD_ENTRY                       = ERROR_CODE(0x8002D00E),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROC_PARAM                 = ERROR_CODE(0x8002D00F),
	SCE_KERNEL_ERROR_MODULEMGR_NO_MODOBJ                          = ERROR_CODE(0x8002D010),
	SCE_KERNEL_ERROR_MODULEMGR_NO_MOD                             = ERROR_CODE(0x8002D011),
	SCE_KERNEL_ERROR_MODULEMGR_NO_PROCESS                         = ERROR_CODE(0x8002D012),
	SCE_KERNEL_ERROR_MODULEMGR_OLD_LIB                            = ERROR_CODE(0x8002D013),
	SCE_KERNEL_ERROR_MODULEMGR_STARTED                            = ERROR_CODE(0x8002D014),
	SCE_KERNEL_ERROR_MODULEMGR_NOT_STARTED                        = ERROR_CODE(0x8002D015),
	SCE_KERNEL_ERROR_MODULEMGR_NOT_STOPPED                        = ERROR_CODE(0x8002D016),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROCESS_UID                = ERROR_CODE(0x8002D017),
	SCE_KERNEL_ERROR_MODULEMGR_CANNOT_EXPORT_LIB_TO_SHARED        = ERROR_CODE(0x8002D018),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_REL_INFO                   = ERROR_CODE(0x8002D019),
	SCE_KERNEL_ERROR_MODULEMGR_INVALID_REF_INFO                   = ERROR_CODE(0x8002D01A),
	SCE_KERNEL_ERROR_MODULEMGR_ELINK                              = ERROR_CODE(0x8002D01B),
	SCE_KERNEL_ERROR_MODULEMGR_NOENT                              = ERROR_CODE(0x8002D01C),
	SCE_KERNEL_ERROR_MODULEMGR_BUSY                               = ERROR_CODE(0x8002D01D),
	SCE_KERNEL_ERROR_MODULEMGR_NOEXEC                             = ERROR_CODE(0x8002D01E),
	SCE_KERNEL_ERROR_MODULEMGR_NAMETOOLONG                        = ERROR_CODE(0x8002D01F),
	SCE_KERNEL_ERROR_LIBRARYDB_NOENT                              = ERROR_CODE(0x8002D080),
	SCE_KERNEL_ERROR_LIBRARYDB_NO_LIB                             = ERROR_CODE(0x8002D081),
	SCE_KERNEL_ERROR_LIBRARYDB_NO_MOD                             = ERROR_CODE(0x8002D082),
	SCE_KERNEL_ERROR_AUTHFAIL                                     = ERROR_CODE(0x8002F000),
	SCE_KERNEL_ERROR_NO_AUTH                                      = ERROR_CODE(0x8002F001),
};

template<>
inline const char* arm_error_code::print(SceLibKernelError error)
{
	switch (error)
	{
		STR_CASE(SCE_KERNEL_ERROR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_NOT_IMPLEMENTED);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_ARGUMENT);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_ARGUMENT_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_FLAGS);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_ADDR);
		STR_CASE(SCE_KERNEL_ERROR_UNSUP);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_MODE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_ALIGNMENT);
		STR_CASE(SCE_KERNEL_ERROR_NOSYS);
		STR_CASE(SCE_KERNEL_ERROR_DEBUG_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_DIPSW_NUMBER);
		STR_CASE(SCE_KERNEL_ERROR_CPU_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_MMU_ILLEGAL_L1_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_MMU_L2_INDEX_OVERFLOW);
		STR_CASE(SCE_KERNEL_ERROR_MMU_L2_SIZE_OVERFLOW);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_CPU_AFFINITY);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_MEMORY_ACCESS_PERMISSION);
		STR_CASE(SCE_KERNEL_ERROR_VA2PA_FAULT);
		STR_CASE(SCE_KERNEL_ERROR_VA2PA_MAPPED);
		STR_CASE(SCE_KERNEL_ERROR_VALIDATION_CHECK_FAILED);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_PROCESS_CONTEXT);
		STR_CASE(SCE_KERNEL_ERROR_UID_NAME_TOO_LONG);
		STR_CASE(SCE_KERNEL_ERROR_VARANGE_IS_NOT_PHYSICAL_CONTINUOUS);
		STR_CASE(SCE_KERNEL_ERROR_PHYADDR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_NO_PHYADDR);
		STR_CASE(SCE_KERNEL_ERROR_PHYADDR_USED);
		STR_CASE(SCE_KERNEL_ERROR_PHYADDR_NOT_USED);
		STR_CASE(SCE_KERNEL_ERROR_NO_IOADDR);
		STR_CASE(SCE_KERNEL_ERROR_PHYMEM_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_PHYPAGE_STATUS);
		STR_CASE(SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE);
		STR_CASE(SCE_KERNEL_ERROR_NO_FREE_PHYSICAL_PAGE_UNIT);
		STR_CASE(SCE_KERNEL_ERROR_PHYMEMPART_NOT_EMPTY);
		STR_CASE(SCE_KERNEL_ERROR_NO_PHYMEMPART_LPDDR2);
		STR_CASE(SCE_KERNEL_ERROR_NO_PHYMEMPART_CDRAM);
		STR_CASE(SCE_KERNEL_ERROR_FIXEDHEAP_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_FIXEDHEAP_ILLEGAL_INDEX);
		STR_CASE(SCE_KERNEL_ERROR_FIXEDHEAP_INDEX_OVERFLOW);
		STR_CASE(SCE_KERNEL_ERROR_FIXEDHEAP_NO_CHUNK);
		STR_CASE(SCE_KERNEL_ERROR_UID_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_UID);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_UID_INVALID_ARGUMENT);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_INVALID_UID_RANGE);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_NO_VALID_UID);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_CANNOT_ALLOCATE_UIDENTRY);
		STR_CASE(SCE_KERNEL_ERROR_NOT_PROCESS_UID);
		STR_CASE(SCE_KERNEL_ERROR_NOT_KERNEL_UID);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_UID_CLASS);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_UID_SUBCLASS);
		STR_CASE(SCE_KERNEL_ERROR_UID_CANNOT_FIND_BY_NAME);
		STR_CASE(SCE_KERNEL_ERROR_VIRPAGE_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_VIRPAGE_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_BLOCK_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_BLOCK_ID);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_BLOCK_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_BLOCK_IN_USE);
		STR_CASE(SCE_KERNEL_ERROR_PARTITION_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_PARTITION_ID);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_PARTITION_INDEX);
		STR_CASE(SCE_KERNEL_ERROR_NO_L2PAGETABLE);
		STR_CASE(SCE_KERNEL_ERROR_HEAPLIB_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_HEAP_ID);
		STR_CASE(SCE_KERNEL_ERROR_OUT_OF_RANG);
		STR_CASE(SCE_KERNEL_ERROR_HEAPLIB_NOMEM);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_ADDRESS_SPACE_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_ADDRESS_SPACE_ID);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_PARTITION_INDEX);
		STR_CASE(SCE_KERNEL_ERROR_ADDRESS_SPACE_CANNOT_FIND_PARTITION_BY_ADDR);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_MEMBLOCK_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_REMAP_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_NOT_PHY_CONT_MEMBLOCK);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_CODE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_USERMAP_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_MEMBLOCK_TYPE_FOR_KERNEL_PROCESS);
		STR_CASE(SCE_KERNEL_ERROR_PROCESS_CANNOT_REMAP_MEMBLOCK);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_PHYMEMLOW_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_CANNOT_ALLOC_PHYMEMLOW);
		STR_CASE(SCE_KERNEL_ERROR_UNKNOWN_PHYMEMLOW_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_SYSMEM_BITHEAP_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_CANNOT_ALLOC_BITHEAP);
		STR_CASE(SCE_KERNEL_ERROR_LOADCORE_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_ELF_HEADER);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_SELF_HEADER);
	}

	return nullptr;
}

template<>
inline const char* arm_error_code::print(SceLibKernelError0 error)
{
	switch (error)
	{
		STR_CASE(SCE_KERNEL_ERROR_EXCPMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_EXCPCODE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_EXCPHANDLER);
		STR_CASE(SCE_KERNEL_ERROR_NOTFOUND_EXCPHANDLER);
		STR_CASE(SCE_KERNEL_ERROR_CANNOT_RELEASE_EXCPHANDLER);
		STR_CASE(SCE_KERNEL_ERROR_INTRMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_CONTEXT);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_INTRCODE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_INTRPARAM);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_INTRPRIORITY);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_TARGET_CPU);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_INTRFILTER);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_INTRTYPE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_HANDLER);
		STR_CASE(SCE_KERNEL_ERROR_FOUND_HANDLER);
		STR_CASE(SCE_KERNEL_ERROR_NOTFOUND_HANDLER);
		STR_CASE(SCE_KERNEL_ERROR_NO_MEMORY);
		STR_CASE(SCE_KERNEL_ERROR_DMACMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_ALREADY_QUEUED);
		STR_CASE(SCE_KERNEL_ERROR_NOT_QUEUED);
		STR_CASE(SCE_KERNEL_ERROR_NOT_SETUP);
		STR_CASE(SCE_KERNEL_ERROR_ON_TRANSFERRING);
		STR_CASE(SCE_KERNEL_ERROR_NOT_INITIALIZED);
		STR_CASE(SCE_KERNEL_ERROR_TRANSFERRED);
		STR_CASE(SCE_KERNEL_ERROR_NOT_UNDER_CONTROL);
		STR_CASE(SCE_KERNEL_ERROR_SYSTIMER_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_NO_FREE_TIMER);
		STR_CASE(SCE_KERNEL_ERROR_TIMER_NOT_ALLOCATED);
		STR_CASE(SCE_KERNEL_ERROR_TIMER_COUNTING);
		STR_CASE(SCE_KERNEL_ERROR_TIMER_STOPPED);
		STR_CASE(SCE_KERNEL_ERROR_THREADMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_DORMANT);
		STR_CASE(SCE_KERNEL_ERROR_NOT_DORMANT);
		STR_CASE(SCE_KERNEL_ERROR_UNKNOWN_THID);
		STR_CASE(SCE_KERNEL_ERROR_CAN_NOT_WAIT);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_THID);
		STR_CASE(SCE_KERNEL_ERROR_THREAD_TERMINATED);
		STR_CASE(SCE_KERNEL_ERROR_DELETED);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_TIMEOUT);
		STR_CASE(SCE_KERNEL_ERROR_NOTIFY_CALLBACK);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_DELETE);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_ATTR);
		STR_CASE(SCE_KERNEL_ERROR_EVF_MULTI);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_CANCEL);
		STR_CASE(SCE_KERNEL_ERROR_EVF_COND);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_COUNT);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_PRIORITY);
		STR_CASE(SCE_KERNEL_ERROR_MUTEX_RECURSIVE);
		STR_CASE(SCE_KERNEL_ERROR_MUTEX_LOCK_OVF);
		STR_CASE(SCE_KERNEL_ERROR_MUTEX_NOT_OWNED);
		STR_CASE(SCE_KERNEL_ERROR_MUTEX_UNLOCK_UDF);
		STR_CASE(SCE_KERNEL_ERROR_MUTEX_FAILED_TO_OWN);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_RECURSIVE);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_LOCK_OVF);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_FAILED_TO_OWN);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_NOT_OWNED);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_OWNED);
		STR_CASE(SCE_KERNEL_ERROR_ALARM_CAN_NOT_CANCEL);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_OBJECT_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_KERNEL_TLS_FULL);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_KERNEL_TLS_INDEX);
		STR_CASE(SCE_KERNEL_ERROR_KERNEL_TLS_BUSY);
		STR_CASE(SCE_KERNEL_ERROR_DIFFERENT_UID_CLASS);
		STR_CASE(SCE_KERNEL_ERROR_UNKNOWN_UID);
		STR_CASE(SCE_KERNEL_ERROR_SEMA_ZERO);
		STR_CASE(SCE_KERNEL_ERROR_SEMA_OVF);
		STR_CASE(SCE_KERNEL_ERROR_PMON_NOT_THREAD_MODE);
		STR_CASE(SCE_KERNEL_ERROR_PMON_NOT_CPU_MODE);
		STR_CASE(SCE_KERNEL_ERROR_ALREADY_REGISTERED);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_THREAD_ID);
		STR_CASE(SCE_KERNEL_ERROR_ALREADY_DEBUG_SUSPENDED);
		STR_CASE(SCE_KERNEL_ERROR_NOT_DEBUG_SUSPENDED);
		STR_CASE(SCE_KERNEL_ERROR_CAN_NOT_USE_VFP);
		STR_CASE(SCE_KERNEL_ERROR_RUNNING);
		STR_CASE(SCE_KERNEL_ERROR_EVENT_COND);
		STR_CASE(SCE_KERNEL_ERROR_MSG_PIPE_FULL);
		STR_CASE(SCE_KERNEL_ERROR_MSG_PIPE_EMPTY);
		STR_CASE(SCE_KERNEL_ERROR_ALREADY_SENT);
		STR_CASE(SCE_KERNEL_ERROR_CAN_NOT_SUSPEND);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_ALREADY_INITIALIZED);
		STR_CASE(SCE_KERNEL_ERROR_FAST_MUTEX_NOT_INITIALIZED);
		STR_CASE(SCE_KERNEL_ERROR_THREAD_STOPPED);
		STR_CASE(SCE_KERNEL_ERROR_THREAD_SUSPENDED);
		STR_CASE(SCE_KERNEL_ERROR_NOT_SUSPENDED);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_DELETE_MUTEX);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_CANCEL_MUTEX);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_DELETE_COND);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_CANCEL_COND);
		STR_CASE(SCE_KERNEL_ERROR_LW_MUTEX_NOT_OWNED);
		STR_CASE(SCE_KERNEL_ERROR_LW_MUTEX_LOCK_OVF);
		STR_CASE(SCE_KERNEL_ERROR_LW_MUTEX_UNLOCK_UDF);
		STR_CASE(SCE_KERNEL_ERROR_LW_MUTEX_RECURSIVE);
		STR_CASE(SCE_KERNEL_ERROR_LW_MUTEX_FAILED_TO_OWN);
		STR_CASE(SCE_KERNEL_ERROR_WAIT_DELETE_LW_MUTEX);
		STR_CASE(SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_RECURSIVE);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_LOCK_OVF);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_NOT_OWNED);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_UNLOCK_UDF);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_LOCK);
		STR_CASE(SCE_KERNEL_ERROR_RW_LOCK_FAILED_TO_UNLOCK);
	}

	return nullptr;
}

template<>
inline const char* arm_error_code::print(SceLibKernelError1 error)
{
	switch (error)
	{
		STR_CASE(SCE_KERNEL_ERROR_PROCESSMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_PID);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_PROCESS_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_PLS_FULL);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_PROCESS_STATUS);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_BUDGET_ID);
		STR_CASE(SCE_KERNEL_ERROR_INVALID_BUDGET_SIZE);
		STR_CASE(SCE_KERNEL_ERROR_CP14_DISABLED);
		STR_CASE(SCE_KERNEL_ERROR_EXCEEDED_MAX_PROCESSES);
		STR_CASE(SCE_KERNEL_ERROR_PROCESS_REMAINING);
		STR_CASE(SCE_KERNEL_ERROR_IOFILEMGR_ERROR);
		STR_CASE(SCE_KERNEL_ERROR_IO_NAME_TOO_LONG);
		STR_CASE(SCE_KERNEL_ERROR_IO_REG_DEV);
		STR_CASE(SCE_KERNEL_ERROR_IO_ALIAS_USED);
		STR_CASE(SCE_KERNEL_ERROR_IO_DEL_DEV);
		STR_CASE(SCE_KERNEL_ERROR_IO_WOULD_BLOCK);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_START_FAILED);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_STOP_FAIL);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_IN_USE);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_LIB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_SYSCALL_REG);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOMEM_LIB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOMEM_STUB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOMEM_SELF);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOMEM);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_LIB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_STUB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_FUNC_NID);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_VAR_NID);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_TYPE);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_MOD_ENTRY);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROC_PARAM);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_MODOBJ);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_MOD);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NO_PROCESS);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_OLD_LIB);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_STARTED);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOT_STARTED);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOT_STOPPED);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_PROCESS_UID);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_CANNOT_EXPORT_LIB_TO_SHARED);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_REL_INFO);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_INVALID_REF_INFO);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_ELINK);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOENT);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_BUSY);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NOEXEC);
		STR_CASE(SCE_KERNEL_ERROR_MODULEMGR_NAMETOOLONG);
		STR_CASE(SCE_KERNEL_ERROR_LIBRARYDB_NOENT);
		STR_CASE(SCE_KERNEL_ERROR_LIBRARYDB_NO_LIB);
		STR_CASE(SCE_KERNEL_ERROR_LIBRARYDB_NO_MOD);
		STR_CASE(SCE_KERNEL_ERROR_AUTHFAIL);
		STR_CASE(SCE_KERNEL_ERROR_NO_AUTH);
	}

	return nullptr;
}

enum psv_object_class_t : u32
{
	SCE_KERNEL_UID_CLASS_PROCESS = 0,
	SCE_KERNEL_THREADMGR_UID_CLASS_THREAD = 1,
	SCE_KERNEL_THREADMGR_UID_CLASS_SEMA = 2,
	SCE_KERNEL_THREADMGR_UID_CLASS_EVENT_FLAG = 3,
	SCE_KERNEL_THREADMGR_UID_CLASS_MUTEX = 4,
	SCE_KERNEL_THREADMGR_UID_CLASS_COND = 5,
	SCE_KERNEL_THREADMGR_UID_CLASS_TIMER = 6,
	SCE_KERNEL_THREADMGR_UID_CLASS_MSG_PIPE = 7,
	SCE_KERNEL_THREADMGR_UID_CLASS_CALLBACK = 8,
	SCE_KERNEL_THREADMGR_UID_CLASS_THREAD_EVENT = 9,
};

union SceKernelSysClock
{
	struct
	{
		le_t<u32> low;
		le_t<u32> hi;
	}
	u;

	le_t<u64> quad;
};

struct SceKernelCallFrame
{
	le_t<u32> sp;
	le_t<u32> pc;
};

// Memory Manager definitions

struct SceKernelMemBlockInfo
{
	le_t<u32> size;
	vm::lptr<void> mappedBase;
	le_t<u32> mappedSize;
	le_t<s32> memoryType; // SceKernelMemoryType
	le_t<u32> access;
};

struct SceKernelAllocMemBlockOpt
{
	le_t<u32> size;
	le_t<u32> attr;
	le_t<u32> alignment;
	le_t<s32> uidBaseBlock;
	vm::lcptr<char> strBaseBlockName;
};

// Thread Manager definitions (threads)

using SceKernelThreadEntry = s32(u32 argSize, vm::ptr<void> pArgBlock);

struct SceKernelThreadOptParam
{
	le_t<u32> size;
	le_t<u32> attr;
};

struct SceKernelThreadInfo
{
	le_t<u32> size;
	le_t<s32> processId;
	char name[32];
	le_t<u32> attr;
	le_t<u32> status;
	vm::lptr<SceKernelThreadEntry> entry;
	vm::lptr<void> pStack;
	le_t<u32> stackSize;
	le_t<s32> initPriority;
	le_t<s32> currentPriority;
	le_t<s32> initCpuAffinityMask;
	le_t<s32> currentCpuAffinityMask;
	le_t<s32> currentCpuId;
	le_t<s32> lastExecutedCpuId;
	le_t<u32> waitType;
	le_t<s32> waitId;
	le_t<s32> exitStatus;
	SceKernelSysClock runClocks;
	le_t<u32> intrPreemptCount;
	le_t<u32> threadPreemptCount;
	le_t<u32> threadReleaseCount;
	le_t<s32> changeCpuCount;
	le_t<s32> fNotifyCallback;
	le_t<s32> reserved;
};

struct SceKernelThreadRunStatus
{
	le_t<u32> size;

	struct
	{
		le_t<s32> processId;
		le_t<s32> threadId;
		le_t<s32> priority;

	} cpuInfo[4];
};

struct SceKernelSystemInfo
{
	le_t<u32> size;
	le_t<u32> activeCpuMask;

	struct
	{
		SceKernelSysClock idleClock;
		le_t<u32> comesOutOfIdleCount;
		le_t<u32> threadSwitchCount;

	} cpuInfo[4];
};

// Thread Manager definitions (callbacks)

using SceKernelCallbackFunction = s32(s32 notifyId, s32 notifyCount, s32 notifyArg, vm::ptr<void> pCommon);

struct SceKernelCallbackInfo
{
	le_t<u32> size;
	le_t<s32> callbackId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> threadId;
	vm::lptr<SceKernelCallbackFunction> callbackFunc;
	le_t<s32> notifyId;
	le_t<s32> notifyCount;
	le_t<s32> notifyArg;
	vm::lptr<void> pCommon;
};

// Thread Manager definitions (events)

using SceKernelThreadEventHandler = s32(s32 type, s32 threadId, s32 arg, vm::ptr<void> pCommon);

struct SceKernelEventInfo
{
	le_t<u32> size;
	le_t<s32> eventId;
	char name[32];
	le_t<u32> attr;
	le_t<u32> eventPattern;
	le_t<u64> userData;
	le_t<u32> numWaitThreads;
	le_t<s32> reserved[1];
};

struct SceKernelWaitEvent
{
	le_t<s32> eventId;
	le_t<u32> eventPattern;
};

struct SceKernelResultEvent
{
	le_t<s32> eventId;
	le_t<s32> result;
	le_t<u32> resultPattern;
	le_t<s32> reserved[1];
	le_t<u64> userData;
};

// Thread Manager definitions (event flags)

enum : u32
{
	SCE_KERNEL_EVF_WAITMODE_AND       = 0x00000000,
	SCE_KERNEL_EVF_WAITMODE_OR        = 0x00000001,
	SCE_KERNEL_EVF_WAITMODE_CLEAR_ALL = 0x00000002,
	SCE_KERNEL_EVF_WAITMODE_CLEAR_PAT = 0x00000004,
};

struct SceKernelEventFlagOptParam
{
	le_t<u32> size;
};

struct SceKernelEventFlagInfo
{
	le_t<u32> size;
	le_t<s32> evfId;
	char name[32];
	le_t<u32> attr;
	le_t<u32> initPattern;
	le_t<u32> currentPattern;
	le_t<s32> numWaitThreads;
};

struct psv_event_flag_t
{
	const std::string name; // IPC Name

	atomic_t<u32> ref{ 0x80000000 }; // IPC Ref Counter

	const u32 attr; // Event Flag Attributes
	const u32 init; // Event Flag Init Pattern

	atomic_t<u32> pattern; // Event Flag Pattern

	std::mutex mutex;

	sleep_queue<cpu_thread> sq;

	psv_event_flag_t(const char* name, u32 attr, u32 pattern)
		: name(name)
		, attr(attr)
		, init(pattern)
		, pattern(pattern)
	{
	}

	// Wakeup all waiters to return SCE_KERNEL_ERROR_WAIT_DELETE
	void destroy()
	{
		std::lock_guard<std::mutex> lock(mutex);

		const u32 pattern = this->pattern;

		for (auto& thread : sq)
		{
			static_cast<ARMv7Thread&>(*thread).GPR[0] = SCE_KERNEL_ERROR_WAIT_DELETE;
			static_cast<ARMv7Thread&>(*thread).GPR[1] = pattern;
			thread->state += cpu_state::signal;
			thread->notify();
		}
	}
};

inline bool event_flag_test(u32 value, u32 pattern, u32 mode)
{
	if (mode & SCE_KERNEL_EVF_WAITMODE_OR)
	{
		return (value & pattern) != 0;
	}
	else
	{
		return (value & pattern) == pattern;
	}
}

inline void event_flag_try_poll(u32& value, u32 pattern, u32 mode)
{
	if (mode & ~7 || (mode & 6) == 6)
	{
		throw EXCEPTION("Unknown mode (0x%x)", mode);
	}

	if (event_flag_test(value, pattern, mode))
	{
		if (mode & SCE_KERNEL_EVF_WAITMODE_CLEAR_ALL)
		{
			value = 0;
		}
		else if (mode & SCE_KERNEL_EVF_WAITMODE_CLEAR_PAT)
		{
			value &= ~pattern;
		}
	}
}

// Thread Manager definitions (semaphores)

struct SceKernelSemaOptParam
{
	le_t<u32> size;
};

struct SceKernelSemaInfo
{
	le_t<u32> size;
	le_t<s32> semaId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> initCount;
	le_t<s32> currentCount;
	le_t<s32> maxCount;
	le_t<s32> numWaitThreads;
};

struct psv_semaphore_t
{
	const std::string name; // IPC Name

	atomic_t<u32> ref{ 0x80000000 }; // IPC Ref Counter

	const u32 attr;
	const s32 max;

	atomic_t<s32> count;

	psv_semaphore_t(const char* name, u32 attr, s32 count, s32 max)
		: name(name)
		, attr(attr)
		, max(max)
		, count(count)
	{
	}
};

// Thread Manager definitions (mutexes)

struct SceKernelMutexOptParam
{
	le_t<u32> size;
	le_t<s32> ceilingPriority;
};

struct SceKernelMutexInfo
{
	le_t<u32> size;
	le_t<s32> mutexId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> initCount;
	le_t<s32> currentCount;
	le_t<s32> currentOwnerId;
	le_t<s32> numWaitThreads;
};

struct psv_mutex_t
{
	const std::string name; // IPC Name

	atomic_t<u32> ref{ 0x80000000 }; // IPC Ref Counter

	const u32 attr;

	atomic_t<s32> count;

	psv_mutex_t(const char* name, u32 attr, s32 count)
		: name(name)
		, attr(attr)
		, count(count)
	{
	}
};

// Thread Manager definitions (lightweight mutexes)

struct SceKernelLwMutexWork
{
	le_t<s32> data[4];
};

struct SceKernelLwMutexOptParam
{
	le_t<u32> size;
};

struct SceKernelLwMutexInfo
{
	le_t<u32> size;
	le_t<s32> uid;
	char name[32];
	le_t<u32> attr;
	vm::lptr<SceKernelLwMutexWork> pWork;
	le_t<s32> initCount;
	le_t<s32> currentCount;
	le_t<s32> currentOwnerId;
	le_t<s32> numWaitThreads;
};

// Thread Manager definitions (condition variables)

struct SceKernelCondOptParam
{
	le_t<u32> size;
};

struct SceKernelCondInfo
{
	le_t<u32> size;
	le_t<s32> condId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> mutexId;
	le_t<u32> numWaitThreads;
};

struct psv_cond_t
{
	const std::string name; // IPC Name

	atomic_t<u32> ref{ 0x80000000 }; // IPC Ref Counter

	const u32 attr;

	const std::shared_ptr<psv_mutex_t> mutex;

	psv_cond_t(const char* name, u32 attr, const std::shared_ptr<psv_mutex_t>& mutex)
		: name(name)
		, attr(attr)
		, mutex(mutex)
	{
	}
};

// Thread Manager definitions (lightweight condition variables)

struct SceKernelLwCondWork
{
	le_t<s32> data[4];
};

struct SceKernelLwCondOptParam
{
	le_t<u32> size;
};

struct SceKernelLwCondInfo
{
	le_t<u32> size;
	le_t<s32> uid;
	char name[32];
	le_t<u32> attr;
	vm::lptr<SceKernelLwCondWork> pWork;
	vm::lptr<SceKernelLwMutexWork> pLwMutex;
	le_t<u32> numWaitThreads;
};

// Thread Manager definitions (timers)

struct SceKernelTimerOptParam
{
	le_t<u32> size;
};

struct SceKernelTimerInfo
{
	le_t<u32> size;
	le_t<s32> timerId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> fActive;
	SceKernelSysClock baseTime;
	SceKernelSysClock currentTime;
	SceKernelSysClock schedule;
	SceKernelSysClock interval;
	le_t<s32> type;
	le_t<s32> fRepeat;
	le_t<s32> numWaitThreads;
	le_t<s32> reserved[1];
};

// Thread Manager definitions (reader/writer locks)

struct SceKernelRWLockOptParam
{
	le_t<u32> size;
};

struct SceKernelRWLockInfo
{
	le_t<u32> size;
	le_t<s32> rwLockId;
	char name[32];
	le_t<u32> attr;
	le_t<s32> lockCount;
	le_t<s32> writeOwnerId;
	le_t<s32> numReadWaitThreads;
	le_t<s32> numWriteWaitThreads;
};

// IO/File Manager definitions

struct SceIoStat
{
	le_t<s32> mode;
	le_t<u32> attr;
	le_t<s64> size;
	SceDateTime ctime;
	SceDateTime atime;
	SceDateTime mtime;
	le_t<u64> _private[6];
};

struct SceIoDirent
{
	SceIoStat d_stat;
	char d_name[256];
	vm::lptr<void> d_private;
	le_t<s32> dummy;
};

// Module
// Aux

inline bool ipc_ref_try_dec(u32& ref)
{
	if (ref & 0x7fffffff)
	{
		// return true if the last reference is removed and object must be deleted
		return !--ref;
	}
	else
	{
		throw EXCEPTION("Unexpected IPC Ref value (0x%x)", ref);
	}
}

inline bool ipc_ref_try_inc(u32& ref)
{
	if (ref & 0x80000000)
	{
		if (!++ref)
		{
			throw EXCEPTION("IPC Ref overflow");
		}

		return true;
	}

	return false;
}

inline bool ipc_ref_try_unregister(u32& ref)
{
	if (ref & 0x80000000)
	{
		ref &= ~0x80000000;

		// return true if object must be deleted
		return !ref;
	}

	throw EXCEPTION("Unexpected IPC Ref value (0x%x)", ref);
}
